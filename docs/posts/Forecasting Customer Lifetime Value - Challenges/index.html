<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.1.189">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Raphael de Brito Tamaki">
<meta name="dcterms.date" content="2023-05-31">

<title>Raphael Tamaki’s Blog - Forecasting Customer Lifetime Value - Challenges</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>

  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Raphael Tamaki’s Blog</span>
    </a>
  </div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html">About</a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/raphaeltamaki"><i class="bi bi-github" role="img">
</i> 
 </a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/raphael-de-brito-tamaki/"><i class="bi bi-linkedin" role="img">
</i> 
 </a>
  </li>  
</ul>
              <div id="quarto-search" class="" title="Search"></div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Forecasting Customer Lifetime Value - Challenges</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">lifetime value</div>
                <div class="quarto-category">marketing</div>
                <div class="quarto-category">digital marketing</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Raphael de Brito Tamaki </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">May 31, 2023</p>
      </div>
    </div>
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">




<p>What are common challenges that we face when building LTV predictions?</p>
<section id="forecasting-lifetime-value---challenges" class="level1">
<h1>Forecasting Lifetime Value - Challenges</h1>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="one_to_rule_them_all.jpeg" class="img-fluid figure-img"></p>
<p></p><figcaption class="figure-caption">One to rule them all</figcaption><p></p>
</figure>
</div>
<p>On the first topic of this series, I explained <a href="https://raphaeltamaki.github.io/raphaeltamaki/posts/Forecasting%20Customer%20Lifetime%20Value%20-%20Why%20Uncertainty%20Matters/">Why Uncertainty Matters</a> in marketing campaigns and how one should adapt the bidding to different degrees of Lifetime Value (LTV) uncertainty and user acquisition response to the bid.</p>
<p>Initially, I was going to demonstrate in this part one way to estimate LTV with confidence intervals. However, I found this was not sufficiently interesting for people who work on this domain, even if I demonstrated using PySTAN. While I did write one notebook instructing how one can predict LTV with uncertainty estimates using XGBoost and PySTAN, which you can see <a href="https://github.com/raphaeltamaki/lifetime_value_forecasting/blob/main/Forecasting%20Customer%20Lifetime%20Value%20-%20Forecasting%20LTV.ipynb">in this notebook</a>, I decided to be more enriching in discussing problems that teams building Lifetime Value prediction models encounter.</p>
<p>This will be a growing section, but for now there are the following topics:</p>
<ul>
<li><strong>One model to rule them all?</strong> LTV predictions can be used for different use cases. Should we have one model for all use cases or one for each?</li>
<li><strong>Should you be using a supervised approach at all?</strong> When LTV predictions are used for marketing, it creates a feedback loop where the model influences the future data it is trained in, similar to what happens in Reinforcement Learning. Is supervised learning appropriate for this situation?</li>
</ul>
<section id="one-model-to-rule-them-all" class="level2">
<h2 class="anchored" data-anchor-id="one-model-to-rule-them-all">1- One model to rule them all?</h2>
<p>One of the most significant benefits of working with LTV estimation is the vast impact that it can have across the company. After all, the Lifetime Value can be used for different goals, such as:</p>
<ul>
<li>prioritizing which product a company should focus on: the greater the (potential) profit a product has, the greater focus the company should have on it</li>
<li>forecasings the cash flow of the following months, thus predicting the financial health of the company</li>
<li>directly influencing marketing by estimating the profitability of endeavors of the marketing team. With an accurate Lifetime Value estimation, the marketing team can quickly scale winning strategies and cut back on the approaches that are not worth it.</li>
</ul>
<p>But this broad impact of Lifetime Value estimation is a double-edged sword because each of those areas has its own needs and definition of an optimum model, which means that a change in the model can have opposite impact on distinct areas. One example is a change that worsens predictions for older users but improves predictions for newer users. This change is positive for the Marketing Team since they mostly care about the prediction for recent users, who were likely acquired by a marketing campaign so that they can better adjust their campaigns bid. On the other hand, the Product Team will oppose such change since older users form the most extensive user base of a product, and worsening the LTV on them may mean applying product changes that are detrimental to the existing users.</p>
<p>This challenge has been previously explored in <a href="https://liftoff.io/blog/pitfalls-of-modeling-ltv-and-how-to-overcome-them/">Pitfalls of Modeling LTV and How to Overcome Them</a> from Algolift (now Liftoff). There it brings four dimensions that may be different depending on the use cases: Stability, Accuracy, Temporal granularity, and Cohort granularity:</p>
<ul>
<li><strong>Stability</strong>: What is a reasonable forecast update frequency? Frequent changes indicates inaccuracy. However, ignoring real surprising behavior that strongly changes LTV is also undesirable.”</li>
<li><strong>Accuracy</strong>: What are an acceptable level of variance (sample size) and bias (model sophistication)?</li>
<li><strong>Temporal granularity</strong>: How soon after installation does the forecast come? Is a cohort a week or a month? Different teams care about different temporal granularity and responsiveness.</li>
<li><strong>Cohort granularity</strong>: Does your end-user care about individual users, all users, or a country?</li>
</ul>
<p>Then, Algolift shows how each use case has different needs and interests for the LTV predictions on those four dimensions:</p>
<table class="table">
<colgroup>
<col style="width: 20%">
<col style="width: 27%">
<col style="width: 29%">
<col style="width: 11%">
<col style="width: 10%">
</colgroup>
<thead>
<tr class="header">
<th>Application</th>
<th>Stability</th>
<th>Accuracy</th>
<th>Temporal Granularity</th>
<th>Cohort Granularity</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Marketing Automation</td>
<td>Less important than responsiveness to market dynamics</td>
<td>Important to be directionally correct without channel/geo bias</td>
<td>0 to 14 days</td>
<td>Campaign: 100 to 1000 users. Paid traffic</td>
</tr>
<tr class="even">
<td>Accounting and Global Revenue Forecasting</td>
<td>Must be stable</td>
<td>Very important for forecast accuracy</td>
<td>Quarterly or Yearly</td>
<td>Country, platform, network, Paid and Organic</td>
</tr>
<tr class="odd">
<td>Product</td>
<td>Must be stable</td>
<td>Relative change more important than absolute value</td>
<td>Months</td>
<td>Country, Platform, network, Paid and Organic</td>
</tr>
</tbody>
</table>
<p>This table shows how each use case has different requirements for the LTV predictions. For example, while Marketing Automation requires that the projections are frequently updated to respond to market changes, this would be detrimental to Accounting. When Accounting needs to forecast the company’s global revenue for the following quarter (or year), having the LTV predictions change means that they can’t validate their forecasts.</p>
<section id="divide-and-conquer" class="level3">
<h3 class="anchored" data-anchor-id="divide-and-conquer">1.1- Divide and conquer</h3>
<p>Since each use case has its demands, creating one model for each use case appears as the most sensible answer. With each model optimized for only one specific metric, it is almost certain that we will reach a better value on each optimization metric. In addition, iterations on the model are much faster by having only one metric to optimize for one stakeholder, which again contributes to a better optimization metric.</p>
<p>But this approach has a scalability problem caused by the maintenance cost for the models and the need to solve for inconsistencies when each model accuses a different LTV. The differences in the predicted LTV are because each model is optimized for other goals, so they won’t necessarily indicate the same absolute values or relative changes in the product or the company. Thus we end up with another much more critical inconsistency problem: the perceived impact of strategic decisions. How can teams conclude when decisive information points to different directions, depending on which team sees it?</p>
<p>The answer is figuring out the source of divergence. While the models may output different values since their targets are not precisely the same, they should be reasonably similar. After all, the target is still the same (LTV), and the cost function is usually the same (ex: MSE). If we notice that models indicate values outside of the typical divergence, we know that at least one of them needs attention. This divergence can be calculated by comparing the output of the models on a period where it is known to have no deviations and then calculating a metric (ex: Mean Squared Error). Anytime the divergence metric falls outside the accepted value, an investigation must be conducted.</p>
<p>While the solution is simple, understanding the reason for the diverging predictions is time-consuming. It means that a Data Scientist, Data Analyst, or Machine Learning Engineer/Scientist has to stop their work to figure out the source of the problem. Depending on the complexity of the problem, it may take several days to find the cause of the differences. Even worse is when the source is not found even after lengthy investigations, and the problem just gets dropped because it is no longer relevant or considered part of the usual divergences between models.</p>
<p>The second problem is the cost of maintaining all the models within acceptable performance standards. This cost can quickly increase as different models often mean different codebases, so the responsible team needs to update in multiple places the same changes or be aware of all the minor differences between the models. As the number of models increases with complexity, supporting various models becomes unsustainable</p>
<p>This problem becomes even clearer when we remember that the machine-learning code is just a small component of the machine-learning system, as best explained in <a href="https://proceedings.neurips.cc/paper_files/paper/2015/file/86df7dcfd896fcaf2674f757a2463eba-Paper.pdf">Hidden Technical Debt in Machine Learning Systems</a>. As shown in the article through the image below, the serving system required to deliver machine-learning predictions has many other components besides the machine-learning (ML) code. And these other components often contain larger codebases</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="ml_infrastructure.png" class="img-fluid figure-img"></p>
<p></p><figcaption class="figure-caption">Depiction of the surrounding infrastructure surrounding the ML code</figcaption><p></p>
</figure>
</div>
<p>By having multiple-machine learning code, we are also multiplying the required infrastructure surrounding our code.</p>
</section>
<section id="my-stance-one-model-to-rule-them-all" class="level3">
<h3 class="anchored" data-anchor-id="my-stance-one-model-to-rule-them-all">1.2 - My stance: one model to rule them all</h3>
<p>With the issues raised before on having multiple LTV models, the best solution appears to always have a single one. Sadly, there is no universal solution for these practical problems. Whether building additional models is beneficial for the company depends on the available headcount to create and maintain these models, the financial impact that more accurate LTV predictions have, and the complexity of the existing code-base.</p>
<p>But to take a stance on this topic, most companies should benefit from having a single machine-learning code-base for the LTV. Based the 4 dimensions brought by AlgoLift and an additional we touched before, I argue that one model (or at least one code base) is frequently the best solution:</p>
<ul>
<li><strong>Temporal and Cohort Granularity (AlgoLift)</strong>: The granularity on how LTV predictions are consumed can be easily accommodated by adding a step that adjusts depending on the need. When the LTV Model predictions are more granular or as granular than what any stakeholder requires, a grouping step</li>
<li><strong>Stability (AlgoLift)</strong>: as shown before, Product and Accounting may require that predictions are constant through time: once something is predicted, it doesn’t change any more. Keeping projections constant can also be solved by creating a mutable and immutable version of LTV predictions.</li>
<li><strong>Accuracy (AlgoLift)</strong>: While clients can have different goals for the LTV model to optimize, most often, they will not cause divergence. For example, the Product cares for directional changes and Marketing Automation for the absolute values. If the LTV model doesn’t follow the changes, it will be biased and won’t satisfy the requirement for marketing.</li>
<li><strong>Iteration speed</strong>: the most potent argument for having multiple models is the ability to implement changes quickly. When a company has numerous different products with unique user bases and particularities, having more than one model can be better. Still, the various models should share many similarities, and I’m in favor of sharing as much code as possible between the models and periodically attempting to unify them. Quite often, the solutions particular to one case are because we need to understand the underlying mechanism properly. When we do, we can find a solution that i s beneficial for all use cases.</li>
</ul>
</section>
<section id="conclusion" class="level3">
<h3 class="anchored" data-anchor-id="conclusion">1.3- Conclusion</h3>
<p>Predicting Lifetime Value can broadly impact the company, creating demands for different variations optimized for each use case. While there are cases where a company should have multiple LTV models, I defend holding with a single model (or at least a single code-base) as much as possible.</p>
</section>
</section>
<section id="should-you-be-using-a-supervised-approach-at-all" class="level2">
<h2 class="anchored" data-anchor-id="should-you-be-using-a-supervised-approach-at-all">2- Should you be using a supervised approach at all?</h2>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="Over_underestmation_Cycle.png" class="img-fluid figure-img"></p>
<p></p><figcaption class="figure-caption">Vicious cyle of over- and underestimation of campaigns by LTV models</figcaption><p></p>
</figure>
</div>
<p>In Lifetime Value prediction, the most common approach is using supervised machine-learning algorithms such as XGBoost. After all, this problem can be easily organized as tabular data, as in the Lifetime Value dataset from Kaggle:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="op">!</span>kaggle datasets download <span class="op">-</span>d baetulo<span class="op">/</span>lifetime<span class="op">-</span>value</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="op">!</span>unzip <span class="op">-</span>j lifetime<span class="op">-</span>value.<span class="bu">zip</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="op">!</span>rm lifetime<span class="op">-</span>value.<span class="bu">zip</span> test.csv</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>Downloading lifetime-value.zip to /Users/raphaeltamaki/Documents/personal_git/lifetime_value_forecasting
 95%|████████████████████████████████████  | 10.0M/10.5M [00:00&lt;00:00, 49.0MB/s]
100%|██████████████████████████████████████| 10.5M/10.5M [00:00&lt;00:00, 45.9MB/s]
Archive:  lifetime-value.zip
  inflating: test.csv                
  inflating: train.csv               </code></pre>
<div class="sourceCode" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>pd.read_csv(<span class="st">'train.csv'</span>).head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div>


<table class="dataframe table table-sm table-striped">
<thead>
<tr>
<th>
</th>
<th>
product_type
</th>
<th>
user_id
</th>
<th>
join_date
</th>
<th>
hidden
</th>
<th>
product
</th>
<th>
STV
</th>
<th>
target
</th>
<th>
credit_card_level
</th>
<th>
is_lp
</th>
<th>
aff_type
</th>
<th>
is_cancelled
</th>
<th>
country_segment
</th>
</tr>
</thead>
<tbody>
<tr>
<th>
0
</th>
<td>
type_ex
</td>
<td>
7.0
</td>
<td>
2018-12-01 00:01:45
</td>
<td>
0
</td>
<td>
product_1
</td>
<td>
8.25
</td>
<td>
8.25
</td>
<td>
standard
</td>
<td>
0
</td>
<td>
PPL
</td>
<td>
NaN
</td>
<td>
US
</td>
</tr>
<tr>
<th>
1
</th>
<td>
type_ex
</td>
<td>
20.0
</td>
<td>
2018-12-01 00:06:05
</td>
<td>
0
</td>
<td>
product_2
</td>
<td>
8.25
</td>
<td>
8.25
</td>
<td>
standard
</td>
<td>
0
</td>
<td>
PPL
</td>
<td>
NaN
</td>
<td>
US
</td>
</tr>
<tr>
<th>
2
</th>
<td>
type_ex
</td>
<td>
22.0
</td>
<td>
2018-12-01 00:06:23
</td>
<td>
0
</td>
<td>
product_3
</td>
<td>
8.25
</td>
<td>
8.25
</td>
<td>
prepaid
</td>
<td>
0
</td>
<td>
PPL
</td>
<td>
NaN
</td>
<td>
US
</td>
</tr>
<tr>
<th>
3
</th>
<td>
type_ex
</td>
<td>
26.0
</td>
<td>
2018-12-01 00:07:12
</td>
<td>
0
</td>
<td>
product_2
</td>
<td>
8.25
</td>
<td>
8.25
</td>
<td>
standard
</td>
<td>
0
</td>
<td>
PPL
</td>
<td>
NaN
</td>
<td>
US
</td>
</tr>
<tr>
<th>
4
</th>
<td>
type_ex
</td>
<td>
59.0
</td>
<td>
2018-12-01 00:15:21
</td>
<td>
0
</td>
<td>
product_2
</td>
<td>
8.25
</td>
<td>
8.25
</td>
<td>
standard
</td>
<td>
0
</td>
<td>
PPL
</td>
<td>
NaN
</td>
<td>
Other Countries
</td>
</tr>
</tbody>

</table>
</div>
<p>While commonplace, this approach faces a problem when its LTV predictions define bids (i.e., CPI, CPA, ROAS) in marketing campaigns. When they are, we create a feedback loop in the system, where the model’s predictions for a set of users impact the probability of further having similar users. Take the example below, where we have 2 marketing campaigns with slightly different types of users. And because they are other users, our model outputs somewhat different predictions, even though they have the same true LTV of $2.00.</p>
<p>Take the example below, where we have 2 marketing campaigns with slightly different types of users. And because they are other users, our model outputs somewhat different predictions, even though they have the same true LTV of $2.00.</p>
<table class="table">
<colgroup>
<col style="width: 4%">
<col style="width: 6%">
<col style="width: 11%">
<col style="width: 11%">
<col style="width: 5%">
<col style="width: 5%">
<col style="width: 6%">
<col style="width: 6%">
<col style="width: 12%">
<col style="width: 15%">
<col style="width: 3%">
<col style="width: 3%">
<col style="width: 4%">
</colgroup>
<thead>
<tr class="header">
<th>Period</th>
<th>True LTV</th>
<th>Predicted LTV (A)</th>
<th>Predicted LTV (B)</th>
<th>CPI (A)</th>
<th>CPI (B)</th>
<th>Users (A)</th>
<th>Users (B)</th>
<th>True Revenue (A+B)</th>
<th>Predicted Revenue (A+B)</th>
<th>Bias</th>
<th>Cost</th>
<th>Profit</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Period 1</td>
<td>$2</td>
<td>$3</td>
<td>$1</td>
<td>$1</td>
<td>$1</td>
<td>100</td>
<td>100</td>
<td>$400</td>
<td>$400</td>
<td>0%</td>
<td>$200</td>
<td>$200</td>
</tr>
</tbody>
</table>
<p>Based on the LTV predictions, the company adjusts the bids for the 2 campaigns by increasing Campaign A’s CPI and decreasing Campaign B’s. Let’s assume for simplicity that the number of users acquired by the 2 campaigns is proportional to their CPI, thus following a linear relationship. In this case, the optimal CPI equals half of the LTV. We then use the updated bids to acquire some users until we observe their LTV.</p>
<table class="table">
<colgroup>
<col style="width: 4%">
<col style="width: 6%">
<col style="width: 11%">
<col style="width: 11%">
<col style="width: 5%">
<col style="width: 5%">
<col style="width: 6%">
<col style="width: 6%">
<col style="width: 12%">
<col style="width: 15%">
<col style="width: 3%">
<col style="width: 4%">
<col style="width: 4%">
</colgroup>
<thead>
<tr class="header">
<th>Period</th>
<th>True LTV</th>
<th>Predicted LTV (A)</th>
<th>Predicted LTV (B)</th>
<th>CPI (A)</th>
<th>CPI (B)</th>
<th>Users (A)</th>
<th>Users (B)</th>
<th>True Revenue (A+B)</th>
<th>Predicted Revenue (A+B)</th>
<th>Bias</th>
<th>Cost</th>
<th>Profit</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Period 1</td>
<td>$2</td>
<td>$3</td>
<td>$1</td>
<td>$1</td>
<td>$1</td>
<td>100</td>
<td>100</td>
<td>$400</td>
<td>$400</td>
<td>0%</td>
<td>$200</td>
<td>$200</td>
</tr>
<tr class="even">
<td>Period 2</td>
<td>$2</td>
<td>$3</td>
<td>$1</td>
<td>$1.50</td>
<td>$0.50</td>
<td>150</td>
<td>50</td>
<td>$400</td>
<td>$500</td>
<td>25%</td>
<td>$250.00</td>
<td>$150</td>
</tr>
</tbody>
</table>
<p>We see that even though initially the LTV model was not biased, we ended up with a biased model after the model’s inputs were used to adjust the bids in the marketing campaigns. In addition, notice that this is not the problem of drift common when training the model since the correct value of LTV didn’t change. And to make things worse, we often only realize that the model is biased because the target (i.e., LTV) of the recently acquired users is only observed after a long time.</p>
<p>However, this is not a problem that always occurs. It only happens when the bids for the campaigns need to be adjusted with the predicted LTV. When they don’t need to be adjusted, we don’t have the previous problem since the number of users doesn’t change.</p>
<table class="table">
<colgroup>
<col style="width: 4%">
<col style="width: 6%">
<col style="width: 11%">
<col style="width: 11%">
<col style="width: 5%">
<col style="width: 5%">
<col style="width: 6%">
<col style="width: 6%">
<col style="width: 12%">
<col style="width: 15%">
<col style="width: 3%">
<col style="width: 4%">
<col style="width: 4%">
</colgroup>
<thead>
<tr class="header">
<th>Period</th>
<th>True LTV</th>
<th>Predicted LTV (A)</th>
<th>Predicted LTV (B)</th>
<th>CPI (A)</th>
<th>CPI (B)</th>
<th>Users (A)</th>
<th>Users (B)</th>
<th>True Revenue (A+B)</th>
<th>Predicted Revenue (A+B)</th>
<th>Bias</th>
<th>Cost</th>
<th>Profit</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Period 1</td>
<td>2</td>
<td>$3</td>
<td>$1</td>
<td>$1.50</td>
<td>$0.50</td>
<td>100</td>
<td>100</td>
<td>$400</td>
<td>$400</td>
<td>0%</td>
<td>$200.00</td>
<td>$200</td>
</tr>
<tr class="even">
<td>Period 2</td>
<td>2</td>
<td>$3</td>
<td>$1</td>
<td>$1.50</td>
<td>$0.50</td>
<td>100</td>
<td>100</td>
<td>$400</td>
<td>$400</td>
<td>0%</td>
<td>$200.00</td>
<td>$200</td>
</tr>
</tbody>
</table>
<p>However, this is an unlikely situation in practice, especially for digital products. The LTV of the recent users varies a lot and quite often, be it because of internal product changes (ex: promotions and feature releases) or because of macro influences (ex: summer vacation). Consequently, the bid used in a marketing campaign needs to be constantly adjusted, and the problem shown before appears.</p>
<section id="correcting-the-ltv-model" class="level3">
<h3 class="anchored" data-anchor-id="correcting-the-ltv-model">2.1- Correcting the LTV Model</h3>
<p>Let’s go back to the first case and suppose that we notice the bias after some time and then retrain the model using the date on the most recent users to remove part of it. We then use the new LTV predictions to adjust the bids.</p>
<table class="table">
<colgroup>
<col style="width: 4%">
<col style="width: 6%">
<col style="width: 11%">
<col style="width: 11%">
<col style="width: 5%">
<col style="width: 5%">
<col style="width: 6%">
<col style="width: 6%">
<col style="width: 12%">
<col style="width: 15%">
<col style="width: 3%">
<col style="width: 4%">
<col style="width: 4%">
</colgroup>
<thead>
<tr class="header">
<th>Period</th>
<th>True LTV</th>
<th>Predicted LTV (A)</th>
<th>Predicted LTV (B)</th>
<th>CPI (A)</th>
<th>CPI (B)</th>
<th>Users (A)</th>
<th>Users (B)</th>
<th>True Revenue (A+B)</th>
<th>Predicted Revenue (A+B)</th>
<th>Bias</th>
<th>Cost</th>
<th>Profit</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Period 2</td>
<td>2</td>
<td>$2.50</td>
<td>$1.50</td>
<td>$1.50</td>
<td>$0.50</td>
<td>150</td>
<td>50</td>
<td>$400</td>
<td>$450</td>
<td>13%</td>
<td>$250.00</td>
<td>$150</td>
</tr>
<tr class="even">
<td>Period 3</td>
<td>2</td>
<td>$2.50</td>
<td>$1.50</td>
<td>$1.25</td>
<td>$0.75</td>
<td>125</td>
<td>75</td>
<td>$400</td>
<td>$425</td>
<td>6%</td>
<td>$212.50</td>
<td>$188</td>
</tr>
</tbody>
</table>
<p>In this situation, the retraining of the model helped make it less biased and increase profits. But notice that we didn’t negate the bias. We only decreased it. What if we tried to zero the bias? Unless we perfectly predicted each audience - which is extremely unlikely, and if achieved, is most likely due to overfitting - then you may have ‘overcorrected’ it:</p>
<table class="table">
<colgroup>
<col style="width: 4%">
<col style="width: 6%">
<col style="width: 11%">
<col style="width: 11%">
<col style="width: 5%">
<col style="width: 5%">
<col style="width: 6%">
<col style="width: 6%">
<col style="width: 12%">
<col style="width: 15%">
<col style="width: 3%">
<col style="width: 4%">
<col style="width: 4%">
</colgroup>
<thead>
<tr class="header">
<th>Period</th>
<th>True LTV</th>
<th>Predicted LTV (A)</th>
<th>Predicted LTV (B)</th>
<th>CPI (A)</th>
<th>CPI (B)</th>
<th>Users (A)</th>
<th>Users (B)</th>
<th>True Revenue (A+B)</th>
<th>Predicted Revenue (A+B)</th>
<th>Bias</th>
<th>Cost</th>
<th>Profit</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Period 2</td>
<td>2</td>
<td>$1.50</td>
<td>$3.50</td>
<td>$1.50</td>
<td>$0.50</td>
<td>150</td>
<td>50</td>
<td>$400</td>
<td>$400</td>
<td>0%</td>
<td>$250.00</td>
<td>$150</td>
</tr>
<tr class="even">
<td>Period 3</td>
<td>2</td>
<td>$1.50</td>
<td>$3.50</td>
<td>$0.75</td>
<td>$1.75</td>
<td>75</td>
<td>175</td>
<td>$500</td>
<td>$725</td>
<td>45%</td>
<td>$362.50</td>
<td>$138</td>
</tr>
</tbody>
</table>
<p>When the errors on those campaigns are large, this can create a vicious cycle where campaigns are scaled up and down as they get over- and undervalued. This happens because to remove the bias, the only way besides nailing the values is by inverting which segment is over- /underestimated. This is caused by the disbalance between the number of users suffering from over-/underestimation, requiring you to overestimate the (now) small population to compensate for the larger population of the (then) overestimated users.</p>
<p>Notice further that this solution is not solved by considering the variance of the error, for example, by using Mean Squared Error. The change shown in the table above would still decrease the MSE , measured by the predicted and true revenue of each campaign, for the first period even if later it causes the same problem:</p>
<p><span class="math display">\[MSE = \sum\left(\left(Revenue_{predicted} - Revenue_{Observed}\right)^2\right)\]</span></p>
<p><span class="math display">\[MSE_{period\ 2,\ initial predictions} =\frac{\left(150*3 - 150*2\right)^2 + \left(50*1 - 50*2\right)^2}{2} = 12500\]</span></p>
<p><span class="math display">\[MSE_{period\ 2,\ new predictions} = \frac{(\left(150*1.5 - 150*2\right)^2 + \left(50*3.5 - 50*2\right)^2}{2} = 5625\]</span></p>
<p>So while it may be initially unintuitive, having your models constantly updated on the most recent data and aiming for no bias may keep the bias present in the model, just alternating the contributors to the bias.</p>
</section>
<section id="solving-the-overcorrection" class="level3">
<h3 class="anchored" data-anchor-id="solving-the-overcorrection">2.2- Solving the ‘overcorrection’</h3>
<p>Since the predictions of the model influence the data that will appear in the future, this sounds like a typical use case for Reinforcement Learning. While it is true that the model is affecting its future data, this doesn’t fall into the domain of Reinforcement Learning because the <strong>action</strong> (i.e., the bids used to acquire the users) doesn’t influence the users themselves. The bid only changes the <strong>proportion</strong> of the type of users that the model sees.</p>
<p>The immediate thought is that we should thus ignore weighting the campaigns by how much revenue they generate. While this will remove the bias, it is a problem of neglecting the most relevant campaigns and overvaluing the small ones. This solution is especially problematic for a company with a mature marketing department, where they constantly explore marketing strategies through small experiments.</p>
<p>A better solution is to <strong>keep the use-base proportion constant</strong>. Instead of directly using the data of the users of the most recent period, sample them based on the number of users from before and use the sampled data to train the LTV models. With this, we still use the most recent (and thus informative) data about our users while avoiding the problem we just highlighted.</p>
<p>Take the example from before where we ‘overcorrected’ for the bias. In that case, not only did we remove the bias, but we also decreased the variance (as per the MSE). If we were instead to use the number of users (or proportion of users) from the previous period, we would see both an actual increase in bias and variance:</p>
<p><span class="math display">\[MSE_{period\ 1,\ initial predictions} =\frac{\left(100*3 - 100*2\right)^2 + \left(100*1 - 100*2\right)^2}{2} = 10000\]</span></p>
<p><span class="math display">\[MSE_{period\ 1,\ new predictions} = \frac{(\left(100*1.5 - 100*2\right)^2 + \left(100*3.5 - 100*2\right)^2}{2} = 12500\]</span></p>
</section>
<section id="conclusion-1" class="level3">
<h3 class="anchored" data-anchor-id="conclusion-1">2.3- Conclusion</h3>
<p>Lifetime Value estimation is already a complex problem, but it can be worse when the model’s predictions are used in marketing campaigns. In this case, using standard metrics such as MSE will not prevent the LTV models from causing a vicious cycle of over- and underestimation of different segments of users. And while it may seem that a Reinforcement Learning approach could solve the problem, it won’t. Instead, one should still use a supervised learning approach but not directly use the most recent users to train the models and sample the new users based on the proportion of users from the same segment in a previous period.</p>
</section>
</section>
<section id="references" class="level2">
<h2 class="anchored" data-anchor-id="references">References</h2>
<ol type="1">
<li><a href="https://raphaeltamaki.github.io/raphaeltamaki/posts/Forecasting%20Customer%20Lifetime%20Value%20-%20Why%20Uncertainty%20Matters/">Why Uncertainty Matters</a></li>
<li><a href="https://liftoff.io/blog/pitfalls-of-modeling-ltv-and-how-to-overcome-them/">Pitfalls of Modeling LTV and How to Overcome Them</a></li>
<li><a href="https://proceedings.neurips.cc/paper_files/paper/2015/file/86df7dcfd896fcaf2674f757a2463eba-Paper.pdf">Hidden Technical Debt in Machine Learning Systems</a></li>
</ol>
<div class="sourceCode" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    setTimeout(function() {
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const cites = ref.parentNode.getAttribute('data-cites').split(' ');
    tippyHover(ref, function() {
      var popup = window.document.createElement('div');
      cites.forEach(function(cite) {
        var citeDiv = window.document.createElement('div');
        citeDiv.classList.add('hanging-indent');
        citeDiv.classList.add('csl-entry');
        var biblioDiv = window.document.getElementById('ref-' + cite);
        if (biblioDiv) {
          citeDiv.innerHTML = biblioDiv.innerHTML;
        }
        popup.appendChild(citeDiv);
      });
      return popup.innerHTML;
    });
  }
});
</script>
</div> <!-- /content -->



</body></html>